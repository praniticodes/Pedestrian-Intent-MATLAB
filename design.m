function [allData, scenario, sensors] = design()
%design - Returns sensor detections
%    allData = design returns sensor detections in a structure
%    with time for an internally defined scenario and sensor suite.
%
%    [allData, scenario, sensors] = design optionally returns
%    the drivingScenario and detection generator objects.

% Generated by MATLAB(R) 24.2 (R2024b) and Automated Driving Toolbox 24.2 (R2024b).
% Generated on: 30-Jun-2025 01:59:50

% Create the drivingScenario object and ego car
[scenario, egoVehicle] = createDrivingScenario;

% Create all the sensors
[sensors, numSensors] = createSensors(scenario);

% Add sensors to scenario
addSensors(scenario, sensors, egoVehicle.ActorID);

allData = struct('Time', {}, 'ActorPoses', {}, 'ObjectDetections', {}, 'LaneDetections', {}, 'PointClouds', {}, 'INSMeasurements', {});
f = figure('Name', 'Live Scenario View');
ax = axes('Parent', f);
running = true;
while running

    time  = scenario.SimulationTime;

    objectDetections = {};
    laneDetections   = [];
    ptClouds = {};
    insMeas = {};
    isValidTime = false(1, numSensors);
    isValidLaneTime = false(1, numSensors);
    isValidPointCloudTime = false(1, numSensors);
    isValidINSTime = false(1, numSensors);

    % Generate detections for each sensor
    for sensorIndex = 1:numSensors
        sensor = sensors{sensorIndex};
        if ~isa(sensor,'insSensor')
            poses = targetPoses(scenario,sensor.SensorIndex);
        end
        % Generate the ego vehicle lane boundaries
        if isa(sensor, 'visionDetectionGenerator')
            maxLaneDetectionRange = min(500,sensor.MaxRange);
            lanes = laneBoundaries(egoVehicle, 'XDistance', linspace(-maxLaneDetectionRange, maxLaneDetectionRange, 101));
        end
        type = getDetectorOutput(sensor);
        if strcmp(type, 'Objects only')
            if isa(sensor,'ultrasonicDetectionGenerator')
                [objectDets, isValidTime(sensorIndex)] = sensor(poses, time);
                numObjects = length(objectDets);
            else
                [objectDets, numObjects, isValidTime(sensorIndex)] = sensor(poses, time);
            end
            objectDetections = [objectDetections; objectDets(1:numObjects)]; %#ok<AGROW>
        elseif strcmp(type, 'Lanes only')
            [laneDets, ~, isValidTime(sensorIndex)] = sensor(lanes, time);
            laneDetections   = [laneDetections laneDets]; %#ok<AGROW>
        elseif strcmp(type, 'Lanes and objects')
            [objectDets, numObjects, isValidTime(sensorIndex), laneDets, ~, isValidLaneTime(sensorIndex)] = sensor(poses, lanes, time);
            objectDetections = [objectDetections; objectDets(1:numObjects)]; %#ok<AGROW>
            laneDetections   = [laneDetections laneDets]; %#ok<AGROW>
        elseif strcmp(type, 'Lanes with occlusion')
            [laneDets, ~, isValidLaneTime(sensorIndex)] = sensor(poses, lanes, time);
            laneDetections   = [laneDetections laneDets]; %#ok<AGROW>
        elseif strcmp(type, 'PointCloud')
            [ptCloud, isValidPointCloudTime(sensorIndex)] = sensor();
            ptClouds = [ptClouds; ptCloud]; %#ok<AGROW>
        elseif strcmp(type, 'INSMeasurement')
            insMeasCurrent = sensor(actorState, time);
            insMeas = [insMeas; insMeasCurrent]; %#ok<AGROW>
            isValidINSTime(sensorIndex) = true;
        end
    end

    % Aggregate all detections into a structure for later use
    if any(isValidTime) || any(isValidLaneTime) || any(isValidPointCloudTime) || any(isValidINSTime)
        allData(end + 1) = struct( ...
            'Time',       scenario.SimulationTime, ...
            'ActorPoses', actorPoses(scenario), ...
            'ObjectDetections', {objectDetections}, ...
            'LaneDetections', {laneDetections}, ...
            'PointClouds',   {ptClouds}, ... %#ok<AGROW>
            'INSMeasurements',   {insMeas}); %#ok<AGROW>
    end

    % Advance the scenario one time step and exit the loop if the scenario is complete
    running = advance(scenario);
    cla(ax);  % Clear axes
plot(scenario, 'Parent', ax);
title(ax, sprintf('Time = %.1f sec', scenario.SimulationTime));
drawnow;

end

% Restart the driving scenario to return the actors to their initial positions.
restart(scenario);

% Release all the sensor objects so they can be used again.
for sensorIndex = 1:numSensors
    release(sensors{sensorIndex});
end

%%%%%%%%%%%%%%%%%%%%
% Helper functions %
%%%%%%%%%%%%%%%%%%%%

% Units used in createSensors and createDrivingScenario
% Distance/Position - meters
% Speed             - meters/second
% Angles            - degrees
% RCS Pattern       - dBsm

function [sensors, numSensors] = createSensors(scenario)
% createSensors Returns all sensor objects to generate detections

% Assign into each sensor the physical and radar profiles for all actors
profiles = actorProfiles(scenario);
sensors{1} = visionDetectionGenerator('SensorIndex', 1, ...
    'SensorLocation', [3.7 0], ...
    'MaxRange', 100, ...
    'DetectorOutput', 'Objects only', ...
    'Intrinsics', cameraIntrinsics([1814.81018227767 1814.81018227767],[320 240],[480 640]), ...
    'ActorProfiles', profiles);
sensors{2} = drivingRadarDataGenerator('SensorIndex', 2, ...
    'MountingLocation', [2.8 -0.9 0.2], ...
    'MountingAngles', [-90 0 0], ...
    'RangeLimits', [0 50], ...
    'TargetReportFormat', 'Detections', ...
    'FieldOfView', [90 5], ...
    'Profiles', profiles);
sensors{3} = visionDetectionGenerator('SensorIndex', 3, ...
    'SensorLocation', [2.8 0.9], ...
    'Yaw', 90, ...
    'MaxRange', 50, ...
    'DetectorOutput', 'Objects only', ...
    'Intrinsics', cameraIntrinsics([320 320],[320 240],[480 640]), ...
    'ActorProfiles', profiles);
sensors{4} = visionDetectionGenerator('SensorIndex', 4, ...
    'SensorLocation', [2.8 -0.9], ...
    'Yaw', -90, ...
    'MaxRange', 50, ...
    'DetectorOutput', 'Objects only', ...
    'Intrinsics', cameraIntrinsics([320 320],[320 240],[480 640]), ...
    'ActorProfiles', profiles);
sensors{5} = lidarPointCloudGenerator('SensorIndex', 5, ...
    'SensorLocation', [0.95 0], ...
    'ActorProfiles', profiles);
sensors{6} = lidarPointCloudGenerator('SensorIndex', 6, ...
    'SensorLocation', [3.7 0], ...
    'MaxRange', 100, ...
    'AzimuthLimits', [-10 10], ...
    'ActorProfiles', profiles);
sensors{7} = drivingRadarDataGenerator('SensorIndex', 7, ...
    'MountingLocation', [-0.939 0.018 0.2], ...
    'TargetReportFormat', 'Detections', ...
    'Profiles', profiles);
sensors{8} = ultrasonicDetectionGenerator('SensorIndex', 8, ...
    'MountingLocation', [2.8 0.9 0.2], ...
    'MountingAngles', [90 0 0], ...
    'Profiles', profiles);
sensors{9} = ultrasonicDetectionGenerator('SensorIndex', 9, ...
    'MountingLocation', [2.8 -0.9 0.2], ...
    'MountingAngles', [-90 0 0], ...
    'Profiles', profiles);
sensors{10} = ultrasonicDetectionGenerator('SensorIndex', 10, ...
    'MountingLocation', [0 0.9 0.2], ...
    'MountingAngles', [90 0 0], ...
    'Profiles', profiles);
sensors{11} = ultrasonicDetectionGenerator('SensorIndex', 11, ...
    'MountingLocation', [0 -0.9 0.2], ...
    'MountingAngles', [-90 0 0], ...
    'Profiles', profiles);
numSensors = 11;

function [scenario, egoVehicle] = createDrivingScenario
% createDrivingScenario Returns the drivingScenario defined in the Designer

% Construct a drivingScenario object.
scenario = drivingScenario;

% Add all road segments
roadCenters = [36.14 -10.48 0;
    40.87 -3.66 0;
    41 6.39 0;
    32.09 13.69 0;
    17.84 13.62 0;
    11.3 4.64 0;
    11.23 -4.14 0;
    16.43 -10.96 0;
    36.14 -10.48 0];
marking = [laneMarking('Solid', 'Color', [0.98 0.86 0.36])
    laneMarking('DoubleSolid', 'Color', [0.98 0.86 0.36])
    laneMarking('Solid')];
laneSpecification = lanespec(2, 'Width', 3.925, 'Marking', marking);
road(scenario, roadCenters, 'Lanes', laneSpecification, 'Name', 'Road');

% Add the ego vehicle
egoVehicle = vehicle(scenario, ...
    'ClassID', 1, ...
    'Position', [25.53 -16.25 0.01], ...
    'Mesh', driving.scenario.carMesh, ...
    'PlotColor', [0.635 0.078 0.184], ...
    'Name', 'Car');
waypoints = [25.53 -16.25 0.01;
    32.07 -15.03 0.01;
    35.89 -13.21 0.01;
    39.64 -9.52 0.01;
    42.31 -5.26 0.01;
    43.73 -0.59 0.01;
    43.73 3.94 0.01;
    42.15 8.45 0.01;
    39.14 11.96 0.01;
    35.43 14.25 0.01;
    31.47 15.84 0.01;
    27.4 16.62 0.01;
    22.83 17.04 0.01;
    18.49 16.11 0.01;
    14.48 13.81 0.01;
    11.62 10.14 0.01;
    9.59 6.16 0.01;
    8.68 1.93 0.01;
    8.78 -2.54 0.01;
    10.13 -7.05 0.01;
    12.8 -10.5 0.01;
    16.43 -13.47 0.01;
    20.51 -15.51 0.01;
    25.51 -16.22 0.01;
    32.074 -15.031 0.01];
speed = [80;80;80;80;80;80;80;80;80;80;80;80;80;80;80;80;80;80;80;80;80;80;80;80;80];
%trajectory(egoVehicle, waypoints, speed);

% Add the non-ego actors
pedestrian = actor(scenario, ...
    'ClassID', 4, ...
    'Length', 0.24, ...
    'Width', 0.45, ...
    'Height', 1.7, ...
    'Position', [37.32 -3.41 0.01], ...
    'RCSPattern', [-8 -8;-8 -8], ...
    'Mesh', driving.scenario.pedestrianMesh, ...
    'PlotColor', [0 0.447 0.741], ...
    'Name', 'Pedestrian');
waypoints = [37.32 -3.41 0.01;
    38.84 -4.15 0.01;
    40.56 -5.04 0.01;
    42.18 -5.89 0.01;
    43.5 -6.5 0.01;
    44.42 -4.31 0.01;
    38.02 -1.88 0.01;
    37.27 -3.4 0.01;
    43.46 -6.39 0.01;
    44.14 -4.89 0.01;
    37.83 -2.44 0.01;
    37.44 -3.3 0.01;
    43.41 -6.31 0.01;
    44.32 -4.97 0.01;
    37.78 -2.31 0.01;
    37.31 -3.43 0.01;
    43.5 -6.35 0.01;
    44.1 -4.8 0.01;
    37.87 -2.31 0.01;
    37.31 -3.56 0.01;
    43.5 -6.44 0.01;
    44.27 -4.85 0.01;
    38 -2.35 0.01;
    37.44 -3.51 0.01];
speed = [10;10;10;10;10;10;10;10;10;10;10;10;10;10;10;10;10;10;10;10;10;10;10;10];
trajectory(pedestrian, waypoints, speed);

pedestrian1 = actor(scenario, ...
    'ClassID', 4, ...
    'Length', 0.24, ...
    'Width', 0.45, ...
    'Height', 1.7, ...
    'Position', [30.16 11.72 0.01], ...
    'RCSPattern', [-8 -8;-8 -8], ...
    'Mesh', driving.scenario.pedestrianMesh, ...
    'PlotColor', [0.85 0.325 0.098], ...
    'Name', 'Pedestrian1');
waypoints = [30.16 11.72 0.01;
    31.92 17.02 0.01;
    30.02 17.61 0.01;
    28.76 12.92 0.01;
    30.39 12.6 0.01;
    32.19 17.32 0.01;
    29.75 17.54 0.01;
    28.62 12.7 0.01;
    30.39 12.68 0.01;
    32.1 17.09 0.01;
    29.65 17.56 0.01;
    28.84 14.23 0.01;
    30.84 13.98 0.01;
    32.05 16.94 0.01;
    29.5 17.51 0.01;
    28.84 13.74 0.01;
    31.06 14.03 0.01;
    31.87 16.97 0.01;
    29.45 17.78 0.01;
    28.49 12.4 0.01;
    30.32 11.84 0.01;
    32 17.34 0.01;
    29.63 17.59 0.01;
    28.49 12.68 0.01];
speed = [15;15;15;15;15;15;15;15;15;15;15;15;15;15;15;15;15;15;15;15;15;15;15;15];
trajectory(pedestrian1, waypoints, speed);

pedestrian2 = actor(scenario, ...
    'ClassID', 4, ...
    'Length', 0.24, ...
    'Width', 0.45, ...
    'Height', 1.7, ...
    'Position', [13.49 1.23 0.01], ...
    'RCSPattern', [-8 -8;-8 -8], ...
    'Mesh', driving.scenario.pedestrianMesh, ...
    'PlotColor', [0.929 0.694 0.125], ...
    'Name', 'Pedestrian2');
waypoints = [13.49 1.23 0.01;
    7.91 2.12 0.01;
    7.6 0.79 0.01;
    13.74 0.83 0.01;
    13.74 1.99 0.01;
    7.87 2.3 0.01;
    7.87 0.83 0.01;
    13.69 0.87 0.01;
    13.43 2.03 0.01;
    8.04 2.16 0.01;
    7.78 0.74 0.01;
    13.34 0.56 0.01;
    12.49 2.08 0.01;
    7.87 1.99 0.01;
    7.91 1.01 0.01;
    12.27 0.7 0.01;
    12.09 1.76 0.01;
    7.82 2.21 0.01;
    7.51 0.61 0.01;
    12 1.01 0.01;
    12.14 2.08 0.01;
    8.62 2.12 0.01;
    8.27 0.74 0.01;
    12.63 0.52 0.01;
    11.65 2.16 0.01;
    7.78 2.16 0.01;
    7.73 0.21 0.01;
    12 0.79 0.01;
    12.36 2.16 0.01;
    8.04 2.03 0.01;
    7.82 0.87 0.01;
    12.4 0.79 0.01];
speed = [6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6];
trajectory(pedestrian2, waypoints, speed);

pedestrian3 = actor(scenario, ...
    'ClassID', 4, ...
    'Length', 0.24, ...
    'Width', 0.45, ...
    'Height', 1.7, ...
    'Position', [20.34 -10.94 0.01], ...
    'RCSPattern', [-8 -8;-8 -8], ...
    'Mesh', driving.scenario.pedestrianMesh, ...
    'PlotColor', [0.494 0.184 0.556], ...
    'Name', 'Pedestrian3');
waypoints = [20.34 -10.94 0.01;
    18.6 -15.42 0.01;
    16.13 -14.47 0.01;
    18.71 -8.97 0.01;
    20.62 -10.49 0.01;
    17.98 -14.81 0.01;
    16.36 -13.63 0.01;
    17.98 -11.16 0.01;
    19.83 -12 0.01;
    19.44 -14.81 0.01;
    15.68 -13.57 0.01;
    18.49 -10.15 0.01;
    19.44 -12.17 0.01;
    18.26 -15.81 0.01;
    15.85 -13.85 0.01;
    18.71 -9.87 0.01;
    20.62 -11.5 0.01;
    18.49 -14.97 0.01;
    15.46 -13.85 0.01;
    19.1 -9.98 0.01;
    20.45 -11.61 0.01;
    17.81 -14.97 0.01;
    16.47 -13.4 0.01;
    18.93 -10.32 0.01;
    20.62 -11.67 0.01;
    19.1 -14.53 0.01;
    15.91 -13.35 0.01;
    19.1 -10.38 0.01;
    20.45 -12.17 0.01;
    18.32 -15.31 0.01;
    15.23 -13.8 0.01;
    18.49 -10.1 0.01;
    20.28 -11.83 0.01;
    18.15 -15.59 0.01;
    15.29 -14.47 0.01;
    19.27 -10.21 0.01];
speed = [6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6;6];
trajectory(pedestrian3, waypoints, speed);

function output = getDetectorOutput(sensor)

if isa(sensor, 'visionDetectionGenerator')
    output = sensor.DetectorOutput;
elseif isa(sensor, 'lidarPointCloudGenerator')
    output = 'PointCloud';
elseif isa(sensor, 'insSensor')
    output = 'INSMeasurement';
else
    output = 'Objects only';
end
